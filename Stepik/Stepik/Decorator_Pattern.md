## Шаблон декоратора общего назначения

#### Все декораторы в большинстве случаев делают примерно одно и то же. Наиболее частый шаблон декоратора выглядит следующим образом:

    import functools
    
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # Что-то выполняется до вызова декорируемой функции
            value = func(*args, **kwargs)
            # декорируется возвращаемое значение функции
            # или что-то выполняется после вызова декорируемой функции
            return value
        return wrapper

Для решения проблемы перетирания `__name__ и __doc__ ` на практике используют другой декоратор, который находится в модуле `functools` и называется `wraps`. Таким образом, чтобы предотвратить перетирание атрибутов `__name__ и __doc__ `декорируемой функции, декораторы должны использовать декоратор `functools.wraps`, который сохраняет информацию о первоначальной функции.

## Декоратор измерения времени работы функции

#### Следующий декоратор измеряет и выводит время выполнения декорируемой функции. Декоратор вычисляет время непосредственно перед запуском функции и сразу после ее завершения и выводит разницу подсчитанных времен.

    import functools, time
    
    def timer(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            start = time.perf_counter()
            val = func(*args, **kwargs)
            end = time.perf_counter()
            work_time = end - start
            print(f'Время выполнения {func.__name__}: {round(work_time, 4)} сек.')
            return val
        return wrapper

## Декоратор отслеживания количества вызовов функции
#### Иногда полезно иметь декоратор, который может отслеживать состояние вызова функции. Создадим декоратор, который подсчитывает, сколько раз вызывается функция. Для сохранения состояния счетчика будем использовать пользовательский атрибут функции.

    import functools
    
    def counter(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            wrapper.num += 1
            print(f'Вызов {func.__name__}: {wrapper.num}')
            val = func(*args, **kwargs)
            return val
        wrapper.num = 0
        return wrapper


## Декоратор замедления времени выполнения функции

#### Иногда полезно иметь декоратор, который замедляет время выполнения функции. Создадим декоратор slow_down, который будет добавлять задержку выполнения программы в 1 секунду, прежде чем вызовет декорируемую функцию.


    import functools
    import time
    
    def slow_down(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            time.sleep(1)
            return func(*args, **kwargs)
        return wrapper

## Декораторы с аргументами

####  Для того чтобы создать декоратор, принимающий аргументы, необходимо добавить еще один уровень вложенности, то есть создать функцию, которая возвращает нужный декоратор:

    def print_symbols(symbol, length):
        def decorator(func):
            def wrapper(*args, **kwargs):
                print(symbol * length)
                return func(*args, **kwargs)
            return wrapper
        return decorator

## Декоратор lru_cache

#### Декоратор lru_cache, дает возможность кэшировать результат вычисления функции, используя стратегию Least Recently Used
### Аргументы декоратора lru_cache

#### При декорировании функций с помощью декоратора lru_cache мы можем использовать следующие аргументы:

- `maxsize=128` — максимальный размер кэша (тип int)
- `typed=False` — как кэшировать при разных типах аргументов (тип bool)
#### Если для параметра `maxsize` установлено значение None, то кэш может расти без ограничений.

#### Если для `typed` задано значение True, то результаты вызовов функции для аргументов разных типов будут кэшироваться отдельно. Например, f(3) и f(3.0) будут рассматриваться как отдельные вызовы с разными результатами. Если для typed задано значение False, то вызовы будут рассматриваться как одинаковые.

### Дополнительные методы декоратора lru_cache

#### Чтобы помочь измерить эффективность кэша и настроить параметр maxsize, декорированная функция имеет метод `cache_info(`), который возвращает именованный кортеж, показывающий `hits`, `misses`, `maxsize` и `currsize`.

#### Мы можем использовать информацию, возвращаемую `cache_info()`, чтобы понять, как работает кэш, и настроить его, чтобы найти подходящий баланс между скоростью работы и объемом памяти:

- `hits` – количество значений, которые lru_cache вернул непосредственно из памяти, поскольку они присутствовали в кэше
- `misses` – количество значений, которые были вычислены, а не взяты из памяти
- `maxsize` – это размер кэша, который мы определили, передав его декоратору
- `currsize` – текущий размер кэша

#### Декоратор lru_cache также предоставляет метод `cache_clear()` для очистки кэша.

Приведенный ниже код:

    from functools import lru_cache
    
    @lru_cache(typed=False)
    def concat(text, num):
        return text + ' ' + str(num)

    print(concat('beegeek', 1))
    print(concat('beegeek', 1.0))
    print(concat('beegeek', True))
    print(concat('beegeek', 4.0))
    print(concat('beegeek', 5))
    
    print(concat.cache_info())
    concat.cache_clear()
    print(concat.cache_info())
выводит:

    beegeek 1
    beegeek 1
    beegeek 1
    beegeek 4.0
    beegeek 5
    CacheInfo(hits=2, misses=3, maxsize=128, currsize=3)
    CacheInfo(hits=0, misses=0, maxsize=128, currsize=0)


#### В Python 3.9 появился декоратор `cache`, который работает так же, как и lru_cache, но без ограничений на размер кэша. По сути, применение декоратора cache равнозначно применению декоратору lru_cache(maxsize=None). Такой декоратор работает быстрее чем lru_cache c заданным maxsize, но потребляет больше памяти.
